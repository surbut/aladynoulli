---
title: "plottingAladynoulli"
format: html
---

## Quarto

Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see <https://quarto.org>.

## Running Code

When you click the **Render** button a document will be generated that includes both content and the output of embedded code. You can embed code like this:
```{r}

library(tidyverse)
library(reticulate)

# 2. Activate the environment
use_condaenv("r-tensornoulli")

# 3. Install required packages
#conda_install("r-tensornoulli", packages = c("numpy", "pandas", "scipy"))

# 4. Verify installation
py_config()  # Should show your new environment

# Load the saved model data
model_data <- py_load_object("~/Dropbox (Personal)//aladyn_model_full.pkl")
lambda=model_data$lambda
phi=model_data$phi
Y=model_data$Y
event_times=model_data$event_times
disease_names=model_data$disease_names
```

```{r}
library(reshape2)
theta=aperm(apply(lambda,c(1,3),function(x){exp(x)/sum(exp(x))}),c(2,1,3))
l=melt(theta)
colnames(l)=c("Individual","Signature","Time","value")
p=ggplot(l[l$Individual%in%sample(1:9661,5),],aes(Time,value,fill=as.factor(Signature)))+geom_area()+facet_wrap(~Individual)+scale_fill_futurama()+labs(x="Time (years from 30)",y="Probability",title="Signature probabilities over time",fill="Signature")


ggsave(p, filename = "signature_probabilities_indvidiaul.pdf", width = 6, height = 4)

```

You can add options to executable code like this 

```{r}

disease_names=readRDS("~/Dropbox (Personal)/disease_names.rds")
phi_logit=aperm(plogis(phi),c(2,1,3))
phi_logit=aperm(phi,c(2,1,3))
rownames(phi_logit)=disease_names
l=melt(phi_logit)
colnames(l)=c("Disease","Signature","Time","value")
p2=ggplot(l[l$Disease%in%c("Coronary atherosclerosis","Myocardial infarction","Angina pectors","Atrial fibrillation and flutter","Congestive heart failure (CHF) NOS"),],aes(Time,value,fill=as.factor(Signature)))+
  geom_area()+facet_wrap(~Disease)+scale_fill_futurama()+labs(x="Time (years from 30)",y="Probability",title="Signature probabilities over time",fill="Signature")
ggsave(p2, filename = "signature_probabilities_disease.pdf", width = 6, height = 4)

```

```{r}
library(ggplot2)
library(viridis)  # for better color gradients

l=merge(l,groups,by.x="Disease",by.y="phenotype",all.x=TRUE)
# Adjusted ggplot
p2 <- ggplot(l, aes(Time, Disease, fill = value)) +
  geom_tile() +
  facet_wrap(~ Signature) +
  labs(x = "Time (years from 30)", y = NULL,  # Removes y-axis label
       title = "Signature probabilities over time", fill = "Signature") +
  scale_fill_viridis(option = "C", direction = -1) +  # Cool-looking viridis color scheme
  theme(axis.text.y = element_blank(),  # Removes y-axis text
        axis.ticks.y = element_blank())  # Removes y-axis ticks

library(dplyr)
library(ggplot2)
library(viridis)

# Step 1: Calculate the average value for ranking
top_diseases <- l %>%
  group_by(Signature, Disease) %>%
  summarize(avg_value = mean(value, na.rm = TRUE)) %>%
  group_by(Signature) %>%
  arrange(Signature, desc(avg_value)) %>%
  slice_head(n = 20) %>%
  ungroup()

# Step 2: Create a unique Disease-Signature combination for filtering
l_top <- l %>%
  inner_join(top_diseases, by = c("Signature", "Disease")) %>%
  merge(groups, by.x = "Disease", by.y = "phenotype", all.x = TRUE)

# Step 3: Create separate disease orders for each signature
l_top <- l_top %>%
  group_by(Signature) %>%
  mutate(Disease = factor(Disease, 
                         levels = unique(Disease[order(avg_value,decreasing = F)]))) %>%
  ungroup()

# Step 4: Plot with free_y scales to allow different diseases per facet
p2 <- ggplot(l_top, aes(Time, Disease, fill = value)) +
  geom_tile() +
  facet_wrap(~ Signature, scales = "free_y", drop = TRUE) +
  labs(x = "Time (years from 30)", y = NULL,
       title = "Top 20 diseases per signature over time", 
       fill = "Weight") +
  scale_fill_viridis_c(option = "C", direction = -1) +
  theme_minimal() +
  theme(axis.text.y = element_text(size = 8),
        strip.text = element_text(size = 10),
        axis.ticks.y = element_blank(),
        panel.spacing = unit(0.5, "lines"))

print(p2)


```


```{r}

# Function to calculate remaining lifetime risk from annual transitions
calc_remaining_risk <- function(pi_pred, from_age) {
  # Convert from 3D array to more manageable form
  N <- dim(pi_pred)[1]
  D <- dim(pi_pred)[2]
  T <- dim(pi_pred)[3]
  
  # For each person and disease, calculate probability of developing disease 
  # between from_age and end of follow-up
  remaining_risk <- array(0, dim=c(N, D))
  
  for(n in 1:N) {
    for(d in 1:D) {
      # Get annual transition probabilities from from_age onwards
      yearly_pi <- pi_pred[n, d, from_age:T]
      # Probability of developing = 1 - prob of never developing
      remaining_risk[n,d] <- 1 - prod(1 - yearly_pi)
    }
  }
  
  return(remaining_risk)
}

# Calculate remaining risk at different ages
ages <- seq(30, 75, by=5)
aladyn_risks <- list()


# Calculate remaining risk at different ages

for(age in ages) {
  time_idx <- age - 29  # Convert age to time index
  aladyn_risks[[as.character(age)]] <- calc_remaining_risk(model_data$pi_pred, time_idx)
}


```

```{r}
# Function to fit Cox model and get predicted risks
# Function to fit Cox model and get predicted risks
fit_cox_risk <- function(event_times, event, sex, smoke, from_age) {
  N <- length(event_times)
  all_risks <- rep(NA, N)  # Initialize risks for everyone
  
  # Create survival data
  df <- data.frame(
    id = 1:N,
    time = as.numeric(event_times),
    event = event,
    sex = sex,
    smoke = smoke
  )
  
  # Get indices of people still at risk
  at_risk_idx <- which(df$time > from_age)
  
  if(length(at_risk_idx) > 0) {
    # Create filtered dataset
    df_risk <- df[at_risk_idx,]
    df_risk$time <- df_risk$time - from_age
    
    # Fit Cox and get risks for at-risk people at a given time (i.e., time varying covariate predictions conditional on risk free age)
    cox_fit <- coxph(Surv(time, event) ~ sex + smoke, data=df_risk)
    at_risk_risks <- 1 - exp(-predict(cox_fit, type="expected"))
    
    # Assign risks back to full population
    all_risks[at_risk_idx] <- at_risk_risks
  }
  
  return(all_risks)
}

# Calculate risks at each age
cox_risks <- list()
for(age in ages) {
  time_idx <- age - 29
  cox_risks[[as.character(age)]] <- matrix(NA, nrow=N, ncol=D)
  
  for(d in 1:D) {
    cox_risks[[as.character(age)]][,d] <- fit_cox_risk(
      event_times = model_data$event_times[,d]+1,
      event = rowSums(Y[,d,time_idx:T]),  # Sum future events
      sex = model_data$metadata$sex,
      smoke = model_data$metadata$smoke,
      from_age = time_idx
    )
  }
}
```


```{r}
library(pROC)


library(pROC)
# Print summary
disease_name_list <- disease_names
# Compare for each age and disease
results <- data.frame()
for(age in ages) {
  for(d in 1:D) {
    # Get predictions
    aladyn_pred <- aladyn_risks[[as.character(age)]][,d]
    cox_pred <- cox_risks[[as.character(age)]][,d]
    
    # Get actual outcomes (future events)
    time_idx <- age - 29
    true_outcome <- rowSums(Y[,d,time_idx:T]) > 0
    
    # Calculate AUCs for non-NA predictions and where we have both outcomes
    valid_idx <- !is.na(cox_pred)
    if(sum(valid_idx) > 0) {
      # Check if we have both positive and negative cases
      if(sum(true_outcome[valid_idx]) > 0 && 
         sum(!true_outcome[valid_idx]) > 0) {
        
        auc_aladyn <- auc(true_outcome[valid_idx], aladyn_pred[valid_idx])
        auc_cox <- auc(true_outcome[valid_idx], cox_pred[valid_idx])
        
        results <- rbind(results, data.frame(
          age = age,
          disease = d,
          disease_name = disease_name_list[d],
          auc_aladyn = auc_aladyn,
          auc_cox = auc_cox,
          n_at_risk = sum(valid_idx),
          n_events = sum(true_outcome[valid_idx])
        ))
      }
    }
  }
}

r=melt(results[,c("age","disease_name","auc_aladyn","auc_cox")],id=c("age","disease_name"))
groups=readRDS("~/Dropbox (Personal)/disease_groups.rds")
r=merge(r,groups,by.x="disease_name",by.y="phenotype",all.x=TRUE)
ggplot(r,aes(x=age,y=value,fill=variable))+geom_boxplot()+
  scale_fill_futurama()+labs(y="AUC",x="Age",fill="Model")+theme_classic()+theme(axis.text.x = element_text(angle = 90))

print(head(results[order(results$auc_aladyn,decreasing = T),]))

mean(results$auc_cox>results$auc_aladyn)

#saveRDS(results,"~/Dropbox (Personal)/results_without_cox_correction.rds")



```

### Now do it where we use the aladyn risks computed above as time varying predictors


```{r}
# Function to fit Cox models and get predicted risks
fit_cox_models <- function(event_times,
                          event,
                          sex,
                          smoke,
                          aladyn_pred,
                          from_age) {
  N <- length(event_times)
  all_risks <- data.frame(
    cox_basic = rep(NA, N),
    cox_aladyn = rep(NA, N),
    cox_combined = rep(NA, N)
  )
  
  all_cs <- data.frame(
    cox_basic = NA,    # Changed: Single value per model
    cox_aladyn = NA,
    cox_combined = NA
  )
  
  # Create survival data
  df <- data.frame(
    id = 1:N,
    time = as.numeric(event_times),
    event = event,
    sex = sex,
    smoke = smoke,
    aladyn_pred = aladyn_pred
  )
  
  # Get indices of people still at risk
  at_risk_idx <- which(df$time > from_age)
  
  if (length(at_risk_idx) > 0) {
    df_risk <- df[at_risk_idx, ]
    df_risk$time <- df_risk$time - from_age
    
    # Fit models and get predictions only if we have enough data
    if(sum(df_risk$event) > 0) {  # Added check for events
      # Fit three models
      cox_basic <- coxph(Surv(time, event) ~ sex + smoke, data = df_risk)
      cox_aladyn <- coxph(Surv(time, event) ~ aladyn_pred, data = df_risk)
      cox_combined <- coxph(Surv(time, event) ~ sex + smoke + aladyn_pred, data = df_risk)
      
      # Get risks
      all_risks$cox_basic[at_risk_idx] <- 1 - exp(-predict(cox_basic, type = "expected"))
      all_risks$cox_aladyn[at_risk_idx] <- 1 - exp(-predict(cox_aladyn, type = "expected"))
      all_risks$cox_combined[at_risk_idx] <- 1 - exp(-predict(cox_combined, type = "expected"))
      
      # Store concordance
      all_cs$cox_basic <- cox_basic$concordance["concordance"]
      all_cs$cox_aladyn <- cox_aladyn$concordance["concordance"]
      all_cs$cox_combined <- cox_combined$concordance["concordance"]
    }
  }
  
  return(list("all_risks" = all_risks, "all_cs" = all_cs))
}

# Calculate risks for all models at each age
all_risks <- list()
all_risk_cs <- list()
for(age in ages) {
  time_idx <- age - 29
  all_risks[[as.character(age)]] <- array(NA, dim=c(N, D, 3))  # 3 models
  all_risk_cs[[as.character(age)]] <- array(NA, dim=c(D, 3))   # Changed: One value per disease/model
  
  for(d in 1:D) {
    risks <- fit_cox_models(
      event_times = model_data$event_times[,d]+1,
      event = rowSums(Y[,d,time_idx:T]),
      sex = model_data$metadata$sex,
      smoke = model_data$metadata$smoke,
      aladyn_pred = aladyn_risks[[as.character(age)]][,d],
      from_age = time_idx
    )
    
    all_risks[[as.character(age)]][,d,] <- as.matrix(risks$all_risks)
    all_risk_cs[[as.character(age)]][d,] <- as.numeric(risks$all_cs)  # Changed: Store concordance correctly
  }
}



# Compare performance
results <- data.frame()
for(age in ages) {
  for(d in 1:D) {
    # Get predictions from all models
    basic_pred <- all_risks[[as.character(age)]][,d,1]
    aladyn_pred <- all_risks[[as.character(age)]][,d,2]
    combined_pred <- all_risks[[as.character(age)]][,d,3]
    
    # Get actual outcomes
    time_idx <- age - 29
    true_outcome <- rowSums(Y[,d,time_idx:T]) > 0
    
    # Calculate AUCs
    valid_idx <- !is.na(basic_pred)
    if(sum(valid_idx) > 0 && 
       sum(true_outcome[valid_idx]) > 0 && 
       sum(!true_outcome[valid_idx]) > 0) {
      
      auc_basic <- auc(true_outcome[valid_idx], basic_pred[valid_idx])
      auc_aladyn <- auc(true_outcome[valid_idx], aladyn_pred[valid_idx])
      auc_combined <- auc(true_outcome[valid_idx], combined_pred[valid_idx])
      
      results <- rbind(results, data.frame(
        age = age,
        disease = d,
        disease_name = disease_name_list[d],
        auc_basic = auc_basic,
        auc_aladyn = auc_aladyn,
        auc_combined = auc_combined,
        n_at_risk = sum(valid_idx),
        n_events = sum(true_outcome[valid_idx])
      ))
    }
  }
}




# Calculate means and SDs

r=melt(results[,c("age","disease_name","auc_basic","auc_aladyn","auc_combined")],id=c("age","disease_name"))

ggplot(r,aes(x=age,y=value,fill=variable))+geom_boxplot()+
  scale_fill_futurama()+labs(y="AUC Across all Diseases of remaining risk",x="Age",fill="Model")+theme_classic()+theme(axis.text.x = element_text(angle = 90))

# Create nicer plot
barplot(means, 
        ylim=c(0,1.1),
        col=c("lightgray","skyblue","lightgreen"),
        names.arg=c("Basic\n(sex+smoke)", "Aladynoulli", "Combined"),
      
        ylab="AUC Across all Diseases of remaining risk")

# Add error bars
arrows(seq(0.7,2.7,1), means-sds, seq(0.7,2.7,1), means+sds, 
       code=3, angle=90, length=0.05)

# Add numeric values
text(seq(0.7,2.7,1), means+0.05, 
     sprintf("%.3f", means))



results2 <- data.frame()
for(age in ages) {
    # Check if we have data for this age
    if(!is.null(all_risk_cs[[as.character(age)]]) && 
       !all(is.na(all_risk_cs[[as.character(age)]]))) {
        
        # Create temporary data frame for this age
        temp_df <- data.frame(
            age = rep(age, D),
            disease = 1:D,
            disease_name = disease_name_list
        )
        
        # Add concordance scores
        temp_df$c_basic <- all_risk_cs[[as.character(age)]][,1]
        temp_df$c_aladyn <- all_risk_cs[[as.character(age)]][,2]
        temp_df$c_combined <- all_risk_cs[[as.character(age)]][,3]
        
        # Append to results
        results2 <- rbind(results2, temp_df)
    }
}


# Calculate means and SDs
sum <- results2[,c("c_basic","c_aladyn","c_combined")]
means <- apply(sum,2,function(x){mean(na.omit(x))})
sds <- apply(sum,2,function(x){sd(na.omit(x))})

# Create nicer plot
barplot(means, 
        ylim=c(0,1.1),
        col=c("lightgray","skyblue","lightgreen"),
        names.arg=c("Basic\n(sex+smoke)", "Aladynoulli", "Combined"),
      
        ylab="Concordance Across all Diseases of remaining risk")

# Add error bars
arrows(seq(0.7,2.7,1), means-sds, seq(0.7,2.7,1), means+sds, 
       code=3, angle=90, length=0.05)

# Add numeric values
text(seq(0.7,2.7,1), means+0.05, 
     sprintf("%.3f", means))

```


```{r}
groups=readRDS("~/Dropbox (Personal)/disease_groups.rds")
results$auc_improvement <- results$auc_aladyn - results$auc_basic
results$rel_improvement <- (results$auc_aladyn - results$auc_basic)/results$auc_basic

# Look at where Aladyn helps most
top_improvements <- results[order(-results$auc_improvement),]
head(top_improvements[,c("disease_name", "age", "auc_basic", "auc_combined", 
                        "auc_improvement", "n_events")])

# 2. Disease-group specific analysis
results_by_group <- merge(results, groups[,c("phenotype","exclude_name")], 
                         by.x="disease_name", by.y="phenotype")

ggsave(ggplot(results_by_group,aes(x=exclude_name,y=auc_improvement,fill=exclude_name))+geom_boxplot()+theme_classic()+labs(y="AUC Improvement",x="Group",fill="Group")+theme(axis.text.x = element_text(angle = 90)),filename = "auc_improvement_by_group.pdf",width = 6, height = 4)



ggsave(
  ggplot(results_by_group,aes(x=age,y=auc_improvement,fill=as.factor(age),group=as.factor(age)))+geom_boxplot()+theme_classic()+labs(y="AUC Improvement",x="Age",fill="Age")+theme(axis.text.x = element_text(angle = 90))
                                                                                                                                       ,filename="auc_improvement_by_age.pdf",width = 6, height = 4)
```


```{r}
pi_pred=model_data$pi_pred
analyze_conditionals <- function(d1, d2, age) {
  time_idx <- age - 29
  
  # Get people at risk for d2
  at_risk <- event_times[,d2] > time_idx
  
  # Calculate probabilities
  marginal <- mean(pi_pred[at_risk, d2, time_idx])
  
  # Conditional on having d1
  has_d1 <- rowSums(Y[, d1, 1:time_idx]) > 0
  cond_yes <- mean(pi_pred[at_risk & has_d1, d2, time_idx])
  cond_no <- mean(pi_pred[at_risk & !has_d1, d2, time_idx])
  
  # Risk ratios
  rr <- cond_yes/cond_no
  
  return(data.frame(
    disease1 = disease_name_list[d1],
    disease2 = disease_name_list[d2],
    age = age,
    marginal = marginal,
    cond_yes = cond_yes,
    cond_no = cond_no,
    risk_ratio = rr
  ))
}

ages=seq(31,80,by=5)
disease_name_list <- disease_names
D=length(disease_name_list)
# Calculate for all pairs of diseases
# Look at all disease pairs at different ages
pairs_analysis <- data.frame()
for(age in ages) {
  for(d1 in 1:D) {
    for(d2 in 1:D) {
      if(d1 != d2) {
        res <- analyze_conditionals(d1, d2, age)
        pairs_analysis <- rbind(pairs_analysis, res)
      }
    }
  }
}

# Find strongest associations
top_pairs <- pairs_analysis[order(-pairs_analysis$risk_ratio),]

```

```{r}
library(tidyverse)
library(viridis)

# Function 1: Topic-specific weight importance over other groups
plot_group_deviations_within_topic <- function(l, groups, target_groups = c("circulatory system", "neoplasms", "neurological")) {
  
  # Calculate mean and std for each signature and time
  topic_stats <- l %>%
    group_by(Signature, Time) %>%
    summarize(mean_weight = mean(value),
             std_weight = sd(value),
             .groups = 'drop')
  
  # Calculate deviations for each group
  group_deviations <- map_df(target_groups, function(group) {
    # Get diseases in this group
    group_diseases <- groups %>%
      filter(exclude_name == group) %>%
      pull(phenotype)
    
    # Calculate group deviation
    l %>%
      filter(Disease %in% group_diseases) %>%
      left_join(topic_stats, by = c("Signature", "Time")) %>%
      group_by(Signature, Time) %>%
      summarize(
        deviation = mean((value - mean_weight) / std_weight),
        group = group,
        .groups = 'drop'
      )
  })
  
  # Plot
  ggplot(group_deviations, aes(x = Time, y = deviation, color = factor(Signature))) +
    geom_line(alpha = 0.7) +
    facet_wrap(~group, ncol = 1, scales = "free_y") +
    geom_hline(yintercept = 0, linetype = "dashed", color = "black", alpha = 0.3) +
     scale_color_npg() +
    labs(x = "Time", y = "Deviation (σ)", color = "Signature",
         title = "Group Deviation Within Topics") +
    theme_minimal() +
    theme(legend.position = "right")
}

# Function 2: Topic-specific group importance vs other topics
plot_group_deviations_across_topics <- function(l, groups, target_groups = c("circulatory system", "neoplasms", "neurological")) {
  
  # Calculate deviations for each group
  group_deviations <- map_df(target_groups, function(group) {
    # Get diseases in this group
    group_diseases <- groups %>%
      filter(exclude_name == group) %>%
      pull(phenotype)
    
    # Calculate mean weight across signatures for these diseases
    signature_means <- l %>%
      filter(Disease %in% group_diseases) %>%
      group_by(Time, Disease) %>%
      summarize(
        mean_across_sigs = mean(value),
        std_across_sigs = sd(value),
        .groups = 'drop'
      )
    
    # Calculate deviation from other signatures
    l %>%
      filter(Disease %in% group_diseases) %>%
      left_join(signature_means, by = c("Time", "Disease")) %>%
      group_by(Signature, Time) %>%
      summarize(
        deviation = mean((value - mean_across_sigs) / std_across_sigs),
        group = group,
        .groups = 'drop'
      )
  })
  
  # Plot
  ggplot(group_deviations, aes(x = Time, y = deviation, color = factor(Signature))) +
    geom_line(alpha = 0.7) +
    facet_wrap(~group, ncol = 1, scales = "free_y") +
    geom_hline(yintercept = 0, linetype = "dashed", color = "black", alpha = 0.3) +
    scale_color_npg() +
    labs(x = "Time", y = "Deviation from mean across signatures (σ)", 
         color = "Signature",
         title = "Group Deviation Across Topics") +
    theme_minimal() +
    theme(legend.position = "right")
}

# Usage:
p1 <- plot_group_deviations_within_topic(l, groups)
p2 <- plot_group_deviations_across_topics(l, groups)

# Display plots
print(p1)
print(p2)

# Optional: Combine plots using patchwork
library(patchwork)
combined_plot <- p1 / p2
print(combined_plot)

ggsave(p1, filename = "group_deviationsz_within.pdf", width = 8, height = 6,dpi=300)
ggsave(p2, filename = "group_deviationsz_between.pdf", width = 8, height = 6,dpi=300)
```


```{r}
library(tidyverse)
library(patchwork)
theta_pred=theta
plot_individual_analysis <- function(theta_pred, Y, G, disease_names, prs_names, 
                                   individual_id=501, start_age=30) {
  
  # Convert data to long format for plotting
  
  # 1. Topic trajectories
  topics_df <- theta_pred[individual_id,, ] %>% 
    as.data.frame() %>%
    mutate(Age = start_age:(start_age + ncol(.) - 1)) %>%
    pivot_longer(-Age, 
                names_to = "Topic", 
                values_to = "Weight",
                names_prefix = "V") # Adjust prefix based on your column names
  
  p1 <- ggplot(topics_df, aes(x = Age, y = Weight, color = Topic)) +
    geom_line() +
    labs(title = paste("Topic Trajectories for Individual", individual_id),
         y = "Topic Weight") +
    theme_minimal() +
    theme(legend.position = "right")
  
  # 2. Disease events
  cv_diseases <- c('Coronary atherosclerosis', 'Myocardial infarction', 
                  'Angina pectoris', 'Cerebrovascular disease', 
                  'Cerebral ischemia', 'Occlusion of cerebral arteries')
  
  disease_indices <- match(cv_diseases, disease_names)
  
  diseases_df <- Y[individual_id, disease_indices, ] %>%
    as.data.frame() %>%
    mutate(Age = start_age:(start_age + ncol(.) - 1)) %>%
    pivot_longer(-Age, 
                names_to = "Disease", 
                values_to = "Status",
                names_prefix = "V") %>%
    mutate(Disease = cv_diseases[as.numeric(str_extract(Disease, "\\d+"))])
  
  p2 <- ggplot(diseases_df, aes(x = Age, y = Status, color = Disease)) +
    geom_line() +
    labs(title = "Disease Events",
         y = "Disease Status") +
    theme_minimal() +
    theme(legend.position = "right")
  
  # 3. Genetic risk scores
  genetic_df <- data.frame(
    PRS = prs_names,
    Value = G[individual_id,]
  )
  
  p3 <- ggplot(genetic_df, aes(x = PRS, y = Value)) +
    geom_col(fill = "steelblue") +
    labs(title = "Genetic Risk Scores",
         y = "PRS Value") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  
  # Combine plots
  combined_plot <- p1 / p2 / p3 +
    plot_layout(heights = c(2, 1, 1))
  
  # Print genetic values
  cat("\nGenetic Risk Scores for Individual", individual_id, ":\n")
  with(genetic_df, cat(paste(PRS, ": ", sprintf("%.3f", Value), "\n", sep="")))
  
  return(combined_plot)
}

# Usage:
plot_individual_analysis(theta_pred, Y, G, disease_names_list, prs_names_list)
```