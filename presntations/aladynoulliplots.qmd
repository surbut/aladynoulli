---
title: "plottingAladynoulli"
format: html
---

## Quarto

Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see <https://quarto.org>.

## Running Code

When you click the **Render** button a document will be generated that includes both content and the output of embedded code. You can embed code like this:
```{r}

library(tidyverse)
library(reticulate)

# 2. Activate the environment
use_condaenv("r-tensornoulli")

# 3. Install required packages
#conda_install("r-tensornoulli", packages = c("numpy", "pandas", "scipy"))

# 4. Verify installation
py_config()  # Should show your new environment

# Load the saved model data
model_data <- py_load_object("~/Dropbox (Personal)//aladyn_model_full.pkl")
lambda=model_data$lambda
phi=model_data$phi
Y=model_data$Y
event_times=model_data$event_times
disease_names=model_data$disease_names
```

```{r}
library(reshape2)
theta=aperm(apply(lambda,c(1,3),function(x){exp(x)/sum(exp(x))}),c(2,1,3))
l=melt(theta)
colnames(l)=c("Individual","Signature","Time","value")
p=ggplot(l[l$Individual%in%sample(1:9661,5),],aes(Time,value,fill=as.factor(Signature)))+geom_area()+facet_wrap(~Individual)+scale_fill_futurama()+labs(x="Time (years from 30)",y="Probability",title="Signature probabilities over time",fill="Signature")


ggsave(p, filename = "signature_probabilities_indvidiaul.pdf", width = 6, height = 4)

```

You can add options to executable code like this 

```{r}

disease_names=readRDS("~/Dropbox (Personal)/disease_names.rds")
phi_logit=aperm(plogis(phi),c(2,1,3))
#phi_logit=aperm(phi,c(2,1,3))
rownames(phi_logit)=disease_names
l=melt(phi_logit)
colnames(l)=c("Disease","Signature","Time","value")
p2=ggplot(l[l$Disease%in%c("Coronary atherosclerosis","Myocardial infarction","Angina pectors","Atrial fibrillation and flutter","Congestive heart failure (CHF) NOS"),],aes(Time,value,fill=as.factor(Signature)))+
  geom_area()+facet_wrap(~Disease)+scale_fill_futurama()+labs(x="Time (years from 30)",y="Probability",title="Signature probabilities over time",fill="Signature")
ggsave(p2, filename = "signature_probabilities_disease.pdf", width = 6, height = 4)

```

```{r}
library(ggplot2)
library(viridis)  # for better color gradients

l=merge(l,groups,by.x="Disease",by.y="phenotype",all.x=TRUE)
# Adjusted ggplot
p2 <- ggplot(l, aes(Time, Disease, fill = value)) +
  geom_tile() +
  facet_wrap(~ Signature) +
  labs(x = "Time (years from 30)", y = NULL,  # Removes y-axis label
       title = "Signature probabilities over time", fill = "Signature") +
  scale_fill_viridis(option = "C") +  # Cool-looking viridis color scheme
  theme(axis.text.y = element_blank(),  # Removes y-axis text
        axis.ticks.y = element_blank())  # Removes y-axis ticks

library(dplyr)
library(ggplot2)
library(viridis)

# Step 1: Calculate the average value for ranking
top_diseases <- l %>%
  group_by(Signature, Disease) %>%
  summarize(avg_value = mean(value, na.rm = TRUE)) %>%
  group_by(Signature) %>%
  arrange(Signature, desc(avg_value)) %>%
  slice_head(n = 20) %>%
  ungroup()

# Step 2: Create a unique Disease-Signature combination for filtering
l_top <- l %>%
  inner_join(top_diseases, by = c("Signature", "Disease")) %>%
  merge(groups, by.x = "Disease", by.y = "phenotype", all.x = TRUE)

# Step 3: Create separate disease orders for each signature
l_top <- l_top %>%
  group_by(Signature) %>%
  mutate(Disease = factor(Disease, 
                         levels = unique(Disease[order(avg_value,decreasing = F)]))) %>%
  ungroup()

# Step 4: Plot with free_y scales to allow different diseases per facet
p2 <- ggplot(l_top, aes(Time, Disease, fill = value)) +
  geom_tile() +
  facet_wrap(~ Signature, scales = "free_y", drop = TRUE) +
  labs(x = "Time (years from 30)", y = NULL,
       title = "Top 20 diseases per signature over time", 
       fill = "Weight") +
  scale_fill_viridis_c(option = "C", direction = +1) +
  theme_minimal() +
  theme(axis.text.y = element_text(size = 8),
        strip.text = element_text(size = 10),
        axis.ticks.y = element_blank(),
        panel.spacing = unit(0.5, "lines"))

print(p2)


```


```{r}

# Function to calculate remaining lifetime risk from annual transitions
calc_remaining_risk <- function(pi_pred, from_age) {
  # Convert from 3D array to more manageable form
  N <- dim(pi_pred)[1]
  D <- dim(pi_pred)[2]
  T <- dim(pi_pred)[3]
  
  # For each person and disease, calculate probability of developing disease 
  # between from_age and end of follow-up
  remaining_risk <- array(0, dim=c(N, D))
  
  for(n in 1:N) {
    for(d in 1:D) {
      # Get annual transition probabilities from from_age onwards
      yearly_pi <- pi_pred[n, d, from_age:T]
      # Probability of developing = 1 - prob of never developing
      remaining_risk[n,d] <- 1 - prod(1 - yearly_pi)
    }
  }
  
  return(remaining_risk)
}

# Calculate remaining risk at different ages
ages <- seq(30, 75, by=5)
aladyn_risks <- list()


# Calculate remaining risk at different ages

for(age in ages) {
  time_idx <- age - 29  # Convert age to time index
  aladyn_risks[[as.character(age)]] <- calc_remaining_risk(model_data$pi_pred, time_idx)
}


```

```{r}
# Function to fit Cox model and get predicted risks
# Function to fit Cox model and get predicted risks
fit_cox_risk <- function(event_times, event, sex, smoke, from_age) {
  N <- length(event_times)
  all_risks <- rep(NA, N)  # Initialize risks for everyone
  
  # Create survival data
  df <- data.frame(
    id = 1:N,
    time = as.numeric(event_times),
    event = event,
    sex = sex,
    smoke = smoke
  )
  
  # Get indices of people still at risk
  at_risk_idx <- which(df$time > from_age)
  
  if(length(at_risk_idx) > 0) {
    # Create filtered dataset
    df_risk <- df[at_risk_idx,]
    df_risk$time <- df_risk$time - from_age
    
    # Fit Cox and get risks for at-risk people at a given time (i.e., time varying covariate predictions conditional on risk free age)
    cox_fit <- coxph(Surv(time, event) ~ sex + smoke, data=df_risk)
    at_risk_risks <- 1 - exp(-predict(cox_fit, type="expected"))
    
    # Assign risks back to full population
    all_risks[at_risk_idx] <- at_risk_risks
  }
  
  return(all_risks)
}

# Calculate risks at each age
cox_risks <- list()
for(age in ages) {
  time_idx <- age - 29
  cox_risks[[as.character(age)]] <- matrix(NA, nrow=N, ncol=D)
  
  for(d in 1:D) {
    cox_risks[[as.character(age)]][,d] <- fit_cox_risk(
      event_times = model_data$event_times[,d]+1,
      event = rowSums(Y[,d,time_idx:T]),  # Sum future events
      sex = model_data$metadata$sex,
      smoke = model_data$metadata$smoke,
      from_age = time_idx
    )
  }
}
```


```{r}
library(pROC)


library(pROC)
# Print summary
disease_name_list <- disease_names
# Compare for each age and disease
results <- data.frame()
for(age in ages) {
  for(d in 1:D) {
    # Get predictions
    aladyn_pred <- aladyn_risks[[as.character(age)]][,d]
    cox_pred <- cox_risks[[as.character(age)]][,d]
    
    # Get actual outcomes (future events)
    time_idx <- age - 29
    true_outcome <- rowSums(Y[,d,time_idx:T]) > 0
    
    # Calculate AUCs for non-NA predictions and where we have both outcomes
    valid_idx <- !is.na(cox_pred)
    if(sum(valid_idx) > 0) {
      # Check if we have both positive and negative cases
      if(sum(true_outcome[valid_idx]) > 0 && 
         sum(!true_outcome[valid_idx]) > 0) {
        
        auc_aladyn <- auc(true_outcome[valid_idx], aladyn_pred[valid_idx])
        auc_cox <- auc(true_outcome[valid_idx], cox_pred[valid_idx])
        
        results <- rbind(results, data.frame(
          age = age,
          disease = d,
          disease_name = disease_name_list[d],
          auc_aladyn = auc_aladyn,
          auc_cox = auc_cox,
          n_at_risk = sum(valid_idx),
          n_events = sum(true_outcome[valid_idx])
        ))
      }
    }
  }
}

r=melt(results[,c("age","disease_name","auc_aladyn","auc_cox")],id=c("age","disease_name"))
groups=readRDS("~/Dropbox (Personal)/disease_groups.rds")
r=merge(r,groups,by.x="disease_name",by.y="phenotype",all.x=TRUE)
ggplot(r,aes(x=age,y=value,fill=variable))+geom_boxplot()+
  scale_fill_futurama()+labs(y="AUC",x="Age",fill="Model")+theme_classic()+theme(axis.text.x = element_text(angle = 90))

print(head(results[order(results$auc_aladyn,decreasing = T),]))

mean(results$auc_cox>results$auc_aladyn)

#saveRDS(results,"~/Dropbox (Personal)/results_without_cox_correction.rds")



```

### Now do it where we use the aladyn risks computed above as time varying predictors


```{r}
# Function to fit Cox models and get predicted risks
fit_cox_models <- function(event_times,
                          event,
                          sex,
                          smoke,
                          aladyn_pred,
                          from_age) {
  N <- length(event_times)
  all_risks <- data.frame(
    cox_basic = rep(NA, N),
    cox_aladyn = rep(NA, N),
    cox_combined = rep(NA, N)
  )
  
  all_cs <- data.frame(
    cox_basic = NA,    # Changed: Single value per model
    cox_aladyn = NA,
    cox_combined = NA
  )
  
  # Create survival data
  df <- data.frame(
    id = 1:N,
    time = as.numeric(event_times),
    event = event,
    sex = sex,
    smoke = smoke,
    aladyn_pred = aladyn_pred
  )
  
  # Get indices of people still at risk
  at_risk_idx <- which(df$time > from_age)
  
  if (length(at_risk_idx) > 0) {
    df_risk <- df[at_risk_idx, ]
    df_risk$time <- df_risk$time - from_age
    
    # Fit models and get predictions only if we have enough data
    if(sum(df_risk$event) > 0) {  # Added check for events
      # Fit three models
      cox_basic <- coxph(Surv(time, event) ~ sex + smoke, data = df_risk)
      cox_aladyn <- coxph(Surv(time, event) ~ aladyn_pred, data = df_risk)
      cox_combined <- coxph(Surv(time, event) ~ sex + smoke + aladyn_pred, data = df_risk)
      
      # Get risks
      all_risks$cox_basic[at_risk_idx] <- 1 - exp(-predict(cox_basic, type = "expected"))
      all_risks$cox_aladyn[at_risk_idx] <- 1 - exp(-predict(cox_aladyn, type = "expected"))
      all_risks$cox_combined[at_risk_idx] <- 1 - exp(-predict(cox_combined, type = "expected"))
      
      # Store concordance
      all_cs$cox_basic <- cox_basic$concordance["concordance"]
      all_cs$cox_aladyn <- cox_aladyn$concordance["concordance"]
      all_cs$cox_combined <- cox_combined$concordance["concordance"]
    }
  }
  
  return(list("all_risks" = all_risks, "all_cs" = all_cs))
}

# Calculate risks for all models at each age
all_risks <- list()
all_risk_cs <- list()
for(age in ages) {
  time_idx <- age - 29
  all_risks[[as.character(age)]] <- array(NA, dim=c(N, D, 3))  # 3 models
  all_risk_cs[[as.character(age)]] <- array(NA, dim=c(D, 3))   # Changed: One value per disease/model
  
  for(d in 1:D) {
    risks <- fit_cox_models(
      event_times = model_data$event_times[,d]+1,
      event = rowSums(Y[,d,time_idx:T]),
      sex = model_data$metadata$sex,
      smoke = model_data$metadata$smoke,
      aladyn_pred = aladyn_risks[[as.character(age)]][,d],
      from_age = time_idx
    )
    
    all_risks[[as.character(age)]][,d,] <- as.matrix(risks$all_risks)
    all_risk_cs[[as.character(age)]][d,] <- as.numeric(risks$all_cs)  # Changed: Store concordance correctly
  }
}



# Compare performance
results <- data.frame()
for(age in ages) {
  for(d in 1:D) {
    # Get predictions from all models
    basic_pred <- all_risks[[as.character(age)]][,d,1]
    aladyn_pred <- all_risks[[as.character(age)]][,d,2]
    combined_pred <- all_risks[[as.character(age)]][,d,3]
    
    # Get actual outcomes
    time_idx <- age - 29
    true_outcome <- rowSums(Y[,d,time_idx:T]) > 0
    
    # Calculate AUCs
    valid_idx <- !is.na(basic_pred)
    if(sum(valid_idx) > 0 && 
       sum(true_outcome[valid_idx]) > 0 && 
       sum(!true_outcome[valid_idx]) > 0) {
      
      auc_basic <- auc(true_outcome[valid_idx], basic_pred[valid_idx])
      auc_aladyn <- auc(true_outcome[valid_idx], aladyn_pred[valid_idx])
      auc_combined <- auc(true_outcome[valid_idx], combined_pred[valid_idx])
      
      results <- rbind(results, data.frame(
        age = age,
        disease = d,
        disease_name = disease_name_list[d],
        auc_basic = auc_basic,
        auc_aladyn = auc_aladyn,
        auc_combined = auc_combined,
        n_at_risk = sum(valid_idx),
        n_events = sum(true_outcome[valid_idx])
      ))
    }
  }
}




# Calculate means and SDs

r=melt(results[,c("age","disease_name","auc_basic","auc_aladyn","auc_combined")],id=c("age","disease_name"))

ggplot(r,aes(x=age,y=value,fill=variable))+geom_boxplot()+
  scale_fill_futurama()+labs(y="AUC Across all Diseases of remaining risk",x="Age",fill="Model")+theme_classic()+theme(axis.text.x = element_text(angle = 90))

# Create nicer plot
barplot(means, 
        ylim=c(0,1.1),
        col=c("lightgray","skyblue","lightgreen"),
        names.arg=c("Basic\n(sex+smoke)", "Aladynoulli", "Combined"),
      
        ylab="AUC Across all Diseases of remaining risk")

# Add error bars
arrows(seq(0.7,2.7,1), means-sds, seq(0.7,2.7,1), means+sds, 
       code=3, angle=90, length=0.05)

# Add numeric values
text(seq(0.7,2.7,1), means+0.05, 
     sprintf("%.3f", means))



results2 <- data.frame()
for(age in ages) {
    # Check if we have data for this age
    if(!is.null(all_risk_cs[[as.character(age)]]) && 
       !all(is.na(all_risk_cs[[as.character(age)]]))) {
        
        # Create temporary data frame for this age
        temp_df <- data.frame(
            age = rep(age, D),
            disease = 1:D,
            disease_name = disease_name_list
        )
        
        # Add concordance scores
        temp_df$c_basic <- all_risk_cs[[as.character(age)]][,1]
        temp_df$c_aladyn <- all_risk_cs[[as.character(age)]][,2]
        temp_df$c_combined <- all_risk_cs[[as.character(age)]][,3]
        
        # Append to results
        results2 <- rbind(results2, temp_df)
    }
}


# Calculate means and SDs
sum <- results2[,c("c_basic","c_aladyn","c_combined")]
means <- apply(sum,2,function(x){mean(na.omit(x))})
sds <- apply(sum,2,function(x){sd(na.omit(x))})

# Create nicer plot
barplot(means, 
        ylim=c(0,1.1),
        col=c("lightgray","skyblue","lightgreen"),
        names.arg=c("Basic\n(sex+smoke)", "Aladynoulli", "Combined"),
      
        ylab="Concordance Across all Diseases of remaining risk")

# Add error bars
arrows(seq(0.7,2.7,1), means-sds, seq(0.7,2.7,1), means+sds, 
       code=3, angle=90, length=0.05)

# Add numeric values
text(seq(0.7,2.7,1), means+0.05, 
     sprintf("%.3f", means))

```


```{r}
groups=readRDS("~/Dropbox (Personal)/disease_groups.rds")
results$auc_improvement <- results$auc_aladyn - results$auc_basic
results$rel_improvement <- (results$auc_aladyn - results$auc_basic)/results$auc_basic

# Look at where Aladyn helps most
top_improvements <- results[order(-results$auc_improvement),]
head(top_improvements[,c("disease_name", "age", "auc_basic", "auc_combined", 
                        "auc_improvement", "n_events")])

# 2. Disease-group specific analysis
results_by_group <- merge(results, groups[,c("phenotype","exclude_name")], 
                         by.x="disease_name", by.y="phenotype")

ggsave(ggplot(results_by_group,aes(x=exclude_name,y=auc_improvement,fill=exclude_name))+geom_boxplot()+theme_classic()+labs(y="AUC Improvement",x="Group",fill="Group")+theme(axis.text.x = element_text(angle = 90)),filename = "auc_improvement_by_group.pdf",width = 6, height = 4)



ggsave(
  ggplot(results_by_group,aes(x=age,y=auc_improvement,fill=as.factor(age),group=as.factor(age)))+geom_boxplot()+theme_classic()+labs(y="AUC Improvement",x="Age",fill="Age")+theme(axis.text.x = element_text(angle = 90))
                                                                                                                                       ,filename="auc_improvement_by_age.pdf",width = 6, height = 4)
```


```{r}
pi_pred=model_data$pi_pred
analyze_conditionals <- function(d1, d2, age) {
  time_idx <- age - 29
  
  # Get people at risk for d2
  at_risk <- event_times[,d2] > time_idx
  
  # Calculate probabilities
  marginal <- mean(pi_pred[at_risk, d2, time_idx])
  
  # Conditional on having d1
  has_d1 <- rowSums(Y[, d1, 1:time_idx]) > 0
  cond_yes <- mean(pi_pred[at_risk & has_d1, d2, time_idx])
  cond_no <- mean(pi_pred[at_risk & !has_d1, d2, time_idx])
  
  # Risk ratios
  rr <- cond_yes/cond_no
  
  return(data.frame(
    disease1 = disease_name_list[d1],
    disease2 = disease_name_list[d2],
    age = age,
    marginal = marginal,
    cond_yes = cond_yes,
    cond_no = cond_no,
    risk_ratio = rr
  ))
}

ages=seq(31,80,by=5)
disease_name_list <- disease_names
D=length(disease_name_list)
# Calculate for all pairs of diseases
# Look at all disease pairs at different ages
pairs_analysis <- data.frame()
for(age in ages) {
  for(d1 in 1:D) {
    for(d2 in 1:D) {
      if(d1 != d2) {
        res <- analyze_conditionals(d1, d2, age)
        pairs_analysis <- rbind(pairs_analysis, res)
      }
    }
  }
}

# Find strongest associations
top_pairs <- pairs_analysis[order(-pairs_analysis$risk_ratio),]

```

```{r}
library(tidyverse)
library(viridis)

# Function 1: Topic-specific weight importance over other groups
plot_group_deviations_within_topic <- function(l, groups, target_groups = c("circulatory system", "neoplasms", "neurological")) {
  
  # Calculate mean and std for each signature and time
  topic_stats <- l %>%
    group_by(Signature, Time) %>%
    summarize(mean_weight = mean(value),
             std_weight = sd(value),
             .groups = 'drop')
  
  # Calculate deviations for each group
  group_deviations <- map_df(target_groups, function(group) {
    # Get diseases in this group
    group_diseases <- groups %>%
      filter(exclude_name == group) %>%
      pull(phenotype)
    
    # Calculate group deviation
    l %>%
      filter(Disease %in% group_diseases) %>%
      left_join(topic_stats, by = c("Signature", "Time")) %>%
      group_by(Signature, Time) %>%
      summarize(
        deviation = mean((value - mean_weight) / std_weight),
        group = group,
        .groups = 'drop'
      )
  })
  
  # Plot
  ggplot(group_deviations, aes(x = Time, y = deviation, color = factor(Signature))) +
    geom_line(alpha = 0.7) +
    facet_wrap(~group, ncol = 1, scales = "free_y") +
    geom_hline(yintercept = 0, linetype = "dashed", color = "black", alpha = 0.3) +
     scale_color_npg() +
    labs(x = "Time", y = "Deviation (σ)", color = "Signature",
         title = "Group Deviation Within Topics") +
    theme_minimal() +
    theme(legend.position = "right")
}

# Function 2: Topic-specific group importance vs other topics
plot_group_deviations_across_topics <- function(l, groups, target_groups = c("circulatory system", "neoplasms", "neurological")) {
  
  # Calculate deviations for each group
  group_deviations <- map_df(target_groups, function(group) {
    # Get diseases in this group
    group_diseases <- groups %>%
      filter(exclude_name == group) %>%
      pull(phenotype)
    
    # Calculate mean weight across signatures for these diseases
    signature_means <- l %>%
      filter(Disease %in% group_diseases) %>%
      group_by(Time, Disease) %>%
      summarize(
        mean_across_sigs = mean(value),
        std_across_sigs = sd(value),
        .groups = 'drop'
      )
    
    # Calculate deviation from other signatures
    l %>%
      filter(Disease %in% group_diseases) %>%
      left_join(signature_means, by = c("Time", "Disease")) %>%
      group_by(Signature, Time) %>%
      summarize(
        deviation = mean((value - mean_across_sigs) / std_across_sigs),
        group = group,
        .groups = 'drop'
      )
  })
  
  # Plot
  ggplot(group_deviations, aes(x = Time, y = deviation, color = factor(Signature))) +
    geom_line(alpha = 0.7) +
    facet_wrap(~group, ncol = 1, scales = "free_y") +
    geom_hline(yintercept = 0, linetype = "dashed", color = "black", alpha = 0.3) +
    scale_color_npg() +
    labs(x = "Time", y = "Deviation from mean across signatures (σ)", 
         color = "Signature",
         title = "Group Deviation Across Topics") +
    theme_minimal() +
    theme(legend.position = "right")
}

# Usage:
p1 <- plot_group_deviations_within_topic(l, groups)
p2 <- plot_group_deviations_across_topics(l, groups)

# Display plots
print(p1)
print(p2)

# Optional: Combine plots using patchwork
library(patchwork)
combined_plot <- p1 / p2
print(combined_plot)

ggsave(p1, filename = "group_deviationsz_within.pdf", width = 8, height = 6,dpi=300)
ggsave(p2, filename = "group_deviationsz_between.pdf", width = 8, height = 6,dpi=300)
```


```{r}
library(tidyverse)
library(patchwork)
theta_pred=theta
prs=readRDS("~/tensornoulli_ehr_new/data/prs.rds")
prs_names=names(prs)

library(tidyverse)
library(patchwork)

plot_individual_analysis <- function(theta_pred, Y, G, disease_names, prs_names, 
                                   individual_id=501, start_age=30) {
  
  
    # Debug prints
  cat("Dimensions and types:\n")
  cat("G dimensions:", dim(G), "\n")
  cat("B dimensions:", dim(B), "\n")
  cat("G class:", class(G), "\n")
  cat("B class:", class(B), "\n")
  
  # Ensure numeric matrices
  G <- as.matrix(G)
  B <- as.matrix(B)
  
  # Calculate number of time points and topics
  n_times <- dim(theta_pred)[3]
  n_topics <- dim(theta_pred)[2]
  age_range <- seq(start_age, start_age + n_times - 1)
  
  # Get individual's genetics and ensure numeric
  g_vec <- as.numeric(G[individual_id,])
  
  # Calculate number of time points
  n_times <- dim(theta_pred)[3]  # assuming theta_pred is [individuals, topics, time]
  age_range <- seq(start_age, start_age + n_times - 1)
  
  # 1. Topic trajectories
  topics_df <- as.data.frame(t(theta_pred[individual_id,,])) %>%
    setNames(paste0("Topic", 1:ncol(.))) %>%
    mutate(Age = age_range) %>%
    pivot_longer(-Age, 
                names_to = "Topic", 
                values_to = "Weight")
  
  p1 <- ggplot(topics_df, aes(x = Age, y = Weight, color = Topic)) +
    geom_line() +
    labs(title = paste("Topic Trajectories for Individual", individual_id),
         y = "Topic Weight") +
    theme_minimal() +
    theme(legend.position = "right")
  
  # 2. Disease events
  cv_diseases <- c('Coronary atherosclerosis', 'Myocardial infarction', 
                  'Angina pectoris', 'Cerebrovascular disease', 
                  'Cerebral ischemia', 'Occlusion of cerebral arteries')
  
  disease_indices <- match(cv_diseases, disease_names)
  
  diseases_df <- as.data.frame(t(Y[individual_id, disease_indices, ])) %>%
    setNames(cv_diseases) %>%
    mutate(Age = age_range) %>%
    pivot_longer(-Age, 
                names_to = "Disease", 
                values_to = "Status")
  
  p2 <- ggplot(diseases_df, aes(x = Age, y = Status, color = Disease)) +
    geom_line() +
    labs(title = "Disease Events",
         y = "Disease Status") +
    theme_minimal() +
    theme(legend.position = "right")
  
  # 3. Genetic risk scores
genetic_df <- G[individual_id,] %>%
    as.data.frame() %>%
    gather(key = "PRS", value = "Value") %>%
    mutate(PRS = str_remove(PRS, "Value."))  # Remove "Value." prefix
  
  p3 <- ggplot(genetic_df, aes(x = reorder(PRS, Value), y = Value)) +  # reorder by value
    geom_col(aes(fill = Value > 0)) +  # Color by positive/negative
    scale_fill_manual(values = c("darkred", "steelblue")) +
    geom_hline(yintercept = 0, linetype = "dashed", alpha = 0.5) +
    labs(title = "Genetic Risk Scores",
         y = "PRS Value (SD units)") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
          legend.position = "none") +
    coord_flip()  # Flip coordinates for better label readability
  
  # Combine plots
  combined_plot <- p1 / p2 / p3 +
    plot_layout(heights = c(2, 1, 1.5))  # Adjusted height for genetic plot
  
  # Print top genetic values
  cat("\nTop 5 highest absolute PRS values for Individual", individual_id, ":\n")
  genetic_df %>%
    arrange(desc(abs(Value))) %>%
    head(5) %>%
    with(cat(paste(PRS, ": ", sprintf("%.3f", Value), "\n", sep="")))
  return(combined_plot)

}

# Usage:
p=plot_individual_analysis(theta_pred = theta_pred, Y = Y, G = prs, disease_names, prs_names =prs_names )
ggsave(p, filename = "individual_analysis.pdf", width = 8, height = 12,dpi=300)
```


```{r}
library(tidyverse)
library(patchwork)

plot_individual_analysis <- function(theta_pred, Y, G, B, disease_names, prs_names, 
                                   individual_id=501, start_age=30) {
  
  # Ensure numeric matrices and proper dimensions
  G <- as.matrix(G)
  B <- as.matrix(B)
  g_vec <- as.numeric(G[individual_id,])
  
  # Calculate number of time points and topics
  n_times <- dim(theta_pred)[3]
  n_topics <- dim(theta_pred)[2]
  age_range <- seq(start_age, start_age + n_times - 1)
  
  # 1. Topic trajectories
  topics_df <- as.data.frame(t(theta_pred[individual_id,,])) %>%
    setNames(paste0("Topic", 1:ncol(.))) %>%
    mutate(Age = age_range) %>%
    pivot_longer(-Age, 
                names_to = "Topic", 
                values_to = "Weight")
  
  p1 <- ggplot(topics_df, aes(x = Age, y = Weight, color = Topic)) +
    geom_line(linewidth = 1) +
    labs(title = paste("Topic Trajectories for Individual", individual_id),
         y = "Topic Weight") +
    theme_minimal() +
    theme(legend.position = "right")
  
  # 2. Disease events
  cv_diseases <- c('Coronary atherosclerosis', 'Myocardial infarction', 
                  'Angina pectoris', 'Cerebrovascular disease', 
                  'Cerebral ischemia', 'Occlusion of cerebral arteries')
  
  disease_indices <- match(cv_diseases, disease_names)
  
  diseases_df <- as.data.frame(t(Y[individual_id, disease_indices, ])) %>%
    setNames(cv_diseases) %>%
    mutate(Age = age_range) %>%
    pivot_longer(-Age, 
                names_to = "Disease", 
                values_to = "Status")
  
  # Find first occurrence of each disease
  disease_onsets <- diseases_df %>%
    group_by(Disease) %>%
    filter(Status == 1) %>%
    summarize(Onset = first(Age)) %>%
    filter(!is.na(Onset))
  
  p2 <- ggplot(diseases_df, aes(x = Age, y = Status, color = Disease)) +
    geom_line(linewidth = 1) +
    geom_vline(data = disease_onsets, 
               aes(xintercept = Onset, color = Disease),
               linetype = "dashed", alpha = 0.5) +
    labs(title = "Disease Events",
         y = "Disease Status") +
    theme_minimal() +
    theme(legend.position = "right")
  
  # 3. Genetic risk scores
  genetic_df <- data.frame(
    PRS = prs_names,
    Value = g_vec
  )
  
  p3 <- ggplot(genetic_df, aes(x = reorder(PRS, Value), y = Value)) +
    geom_col(aes(fill = Value > 0)) +
    scale_fill_manual(values = c("darkred", "steelblue")) +
    geom_hline(yintercept = 0, linetype = "dashed", alpha = 0.5) +
    labs(title = "Genetic Risk Scores",
         y = "PRS Value (SD units)") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
          legend.position = "none") +
    coord_flip()
  
  # 4. Calculate genetic contributions to topics
  contrib_list <- list()
  for(k in 1:n_topics) {
    b_vec <- as.numeric(B[,k])
    contrib <- g_vec * b_vec
    contrib_list[[k]] <- data.frame(
      PRS = prs_names,
      Topic = paste0("Topic", k),
      Contribution = contrib
    )
  }
  
  contrib_df <- do.call(rbind, contrib_list)
  
  # Calculate total contribution for each topic
  topic_totals <- contrib_df %>%
    group_by(Topic) %>%
    summarize(Total = sum(Contribution))
  
  p4 <- ggplot(contrib_df, aes(x = reorder(Topic, -Contribution), y = Contribution, fill = as.factor(PRS))) +
    geom_col(position = "stack") +
    geom_hline(yintercept = 0, linetype = "dashed", alpha = 0.5) +
    #geom_text(data = topic_totals, 
              #aes(x = Topic, y = Total, label = sprintf("%.2f", Total)),
              #position = position_dodge(width = 0.9),
              #vjust = -0.5) +
    labs(title = "Genetic Contributions to Topics",
         y = "Combined Genetic Effect") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  
  # Combine plots
  combined_plot <- (p1 / p2 / p3 / p4) +
    plot_layout(heights = c(2, 1, 1.5, 1.5))
  
  # Print summary statistics
  cat("\nDisease Onsets:\n")
  print(disease_onsets)
  
  cat("\nTop 5 highest absolute PRS values:\n")
  genetic_df %>%
    arrange(desc(abs(Value))) %>%
    head(5) %>%
    with(cat(paste(PRS, ": ", sprintf("%.3f", Value), "\n", sep="")))
  
  cat("\nStrongest genetic contributions by topic:\n")
  contrib_df %>%
    group_by(Topic) %>%
    arrange(desc(abs(Contribution))) %>%
    slice(1) %>%
    ungroup() %>%
    arrange(Topic) %>%
    with(cat(paste(Topic, ": ", PRS, " (", sprintf("%.3f", Contribution), ")\n", sep="")))
  
  return(combined_plot)
}

# Usage:
p2=plot_individual_analysis(theta_pred, Y, G=prs, B=model_data$gamma, 
                        disease_names, prs_names)

ggsave(p2, filename = "individual_analysis_2.pdf", width = 8, height = 12,dpi=300)
```

```{r}
library(tidyverse)
library(pheatmap)
library(viridis)
library(RColorBrewer)
library(grid)
library(gridExtra)

plot_topic_group_enrichment <- function(phi, disease_names, groups, time_points=50) {
  phi=plogis(phi)
  # Define groups to exclude
  exclude_groups <- c("infectious diseases", "injuries & poisonings", "", "symptoms")
  
  # Filter groups
  groups_filtered <- groups %>%
    filter(!exclude_name %in% exclude_groups)
  
  # Create different color palettes for each topic
  color_palettes <- list(
    viridis(100),              # viridis
    magma(100),               # magma
    plasma(100),              # plasma
    inferno(100),             # inferno
    colorRampPalette(brewer.pal(9, "YlOrRd"))(100),   # Yellow-Orange-Red
    colorRampPalette(brewer.pal(9, "YlGnBu"))(100),   # Yellow-Green-Blue
    colorRampPalette(brewer.pal(9, "RdPu"))(100),     # Red-Purple
    colorRampPalette(brewer.pal(9, "PuBuGn"))(100),   # Purple-Blue-Green
    colorRampPalette(brewer.pal(9, "PuRd"))(100),     # Purple-Red
    colorRampPalette(brewer.pal(9, "GnBu"))(100)      # Green-Blue
  )
  
  # Convert phi to array if it's a tensor
  phi_array <- as.array(phi)
  n_topics <- dim(phi_array)[1]
  
  # Calculate mean logOR for each topic, group, and time
  enrichment_by_topic <- map(1:n_topics, function(k) {
    # Get weights for this topic
    topic_weights <- phi_array[k,,]
    
    # Calculate group means at each time point
    remaining_groups <- unique(groups_filtered$exclude_name)
    group_means <- matrix(nrow=length(remaining_groups), 
                         ncol=time_points)
    rownames(group_means) <- remaining_groups
    colnames(group_means) <- paste0("T", 1:time_points)
    
    for(t in 1:time_points) {
      weights_t <- topic_weights[,t]
      # Calculate mean weight for each group
      group_means[,t] <- sapply(remaining_groups, function(g) {
        group_diseases <- which(disease_names %in% 
                              groups_filtered$phenotype[groups_filtered$exclude_name == g])
        if(length(group_diseases) > 0) {
          mean(weights_t[group_diseases])
        } else {
          NA
        }
      })
    }
    
    return(group_means)
  })
  
  # Plot heatmap for each topic and convert to grob
  plot_grobs <- map(1:n_topics, function(k) {
    data <- enrichment_by_topic[[k]]
    
    # Create nicer row names
    rownames(data) <- stringr::str_to_title(rownames(data))
    
    # Get color palette for this topic
    palette_idx <- ((k-1) %% length(color_palettes)) + 1
    
    # Create pheatmap and convert to grob
    ph <- pheatmap(data,
                  main = paste("Topic", k, "Mean Probability by Group"),
                  color = color_palettes[[palette_idx]],
                  cluster_rows = FALSE,
                  cluster_cols = FALSE,
                  show_colnames = FALSE,
                  fontsize = 8,
                  angle_col = 45,
                  silent = TRUE)  # Important: return the pheatmap object
    
    # Convert to grob
    grid.grabExpr(grid.draw(ph$gtable))
  })
  
  # Return both the plots and the data
  return(list(
    plots = plot_grobs,
    data = enrichment_by_topic
  ))
}

# Usage:
result <- plot_topic_group_enrichment(phi, disease_names, groups)

# Arrange plots in a grid
do.call(grid.arrange, c(result$plots, ncol=2))

# Optionally, save the plot
# ggsave("topic_enrichment.pdf", marrangeGrob(grobs=result$plots, ncol=2, nrow=5), width=15, height=30)
```

```{r}


library(tidyverse)
library(pheatmap)
library(RColorBrewer)

plot_genetic_effects <- function(gamma, prs_names, n_topics) {
  # Convert gamma to matrix if needed
  gamma_matrix <- t(as.matrix(gamma))  # transpose to match Python version
  rownames(gamma_matrix) <- paste0("Topic ", 0:(n_topics-1))
  colnames(gamma_matrix) <- prs_names
  
  # Create color palette centered at 0
  colors <- colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(100)
  
  # Create breaks that are symmetric around 0
  max_abs <- max(abs(gamma_matrix))
  breaks <- seq(-max_abs, max_abs, length.out = 101)
  
  # Create the heatmap
  ph <- pheatmap(gamma_matrix,
                 color = colors,
                 breaks = breaks,
                 cluster_rows = FALSE,      # cluster topics
                 cluster_cols = TRUE,      # cluster genetic effects
                 show_rownames = TRUE,
                 show_colnames = TRUE,
                 main = "Genetic Effects (Gamma) Across Topics",
                 fontsize = 8,
                 angle_col = 45,
                 treeheight_row = 20,      # height of dendrogram
                 treeheight_col = 20)
  
   # Return both plots
  return(
    heatmap = ph,
    
  )
}

# Usage:
plots <- plot_genetic_effects(model_data$gamma, prs_names, n_topics=10)

# Display plots
# The heatmap
plots$heatmap

# The Topic 7 barplot
plots$topic7_plot

# Optionally combine plots
library(gridExtra)
grid.arrange(
  grid.grabExpr(grid.draw(plots$heatmap$gtable)),
  plots$topic7_plot,
  ncol = 1,
  heights = c(1.5, 1)
)

# Get clustering order
cluster_order <- plots$heatmap$tree_col$order
print("PRS clustering order:")
print(prs_names_list[cluster_order])






```





```{r}
library(tidyverse)
library(pheatmap)
library(viridis)
library(RColorBrewer)

plot_topic_group_enrichment <- function(phi, disease_names, groups, time_points=50) {
  
  # Define groups to exclude
  exclude_groups <- c("infectious diseases", "injuries & poisonings", "", "symptoms")
  
  # Filter groups
  groups_filtered <- groups %>%
    filter(!exclude_name %in% exclude_groups)
  
  # Convert phi to array if it's a tensor
  phi_array <- as.array(phi)
  n_topics <- dim(phi_array)[1]
  
  # Calculate probabilities for each topic, group, and time
  enrichment_by_topic <- map(1:n_topics, function(k) {
    # Get weights for this topic
    topic_weights <- phi_array[k,,]
    
    # Calculate group means at each time point
    remaining_groups <- unique(groups_filtered$exclude_name)
    group_means <- matrix(nrow=length(remaining_groups), 
                         ncol=time_points)
    rownames(group_means) <- remaining_groups
    colnames(group_means) <- paste0("T", 1:time_points)
    
    for(t in 1:time_points) {
      weights_t <- topic_weights[,t]
      # Calculate mean probability for each group
      group_means[,t] <- sapply(remaining_groups, function(g) {
        group_diseases <- which(disease_names %in% 
                              groups_filtered$phenotype[groups_filtered$exclude_name == g])
        if(length(group_diseases) > 0) {
          mean(plogis(weights_t[group_diseases]))  # Convert to probability
        } else {
          NA
        }
      })
    }
    
    return(group_means)
  })
  
  # Find global min and max for consistent scale
  all_values <- unlist(enrichment_by_topic)
  value_range <- range(all_values, na.rm = TRUE)
  
  # Create color palette (using magma for better intensity visualization)
  colors <- viridis(100, option = "plasma")
  
  # Plot heatmap for each topic
  plot_grobs <- map(1:n_topics, function(k) {
    data <- enrichment_by_topic[[k]]
    
    # Create nicer row names
    rownames(data) <- stringr::str_to_title(rownames(data))
    
    # Create pheatmap with consistent scale
    ph <- pheatmap(data,
                  main = paste("Topic", k, "Mean Probability by Group"),
                  color = colors,
                  cluster_rows = FALSE,
                  cluster_cols = FALSE,
                  show_colnames = FALSE,
                  breaks = seq(value_range[1], value_range[2], length.out = 101),
                  fontsize = 8,
                  angle_col = 45,
                  silent = TRUE)
    
    # Convert to grob
    grid.grabExpr(grid.draw(ph$gtable))
  })
  
  # Return both the plots and the data
  return(list(
    plots = plot_grobs,
    data = enrichment_by_topic,
    value_range = value_range
  ))
}

# Usage:
result <- plot_topic_group_enrichment(phi, disease_names, groups)

# Print value range
cat("Probability range:", sprintf("%.4f to %.4f\n", result$value_range[1], result$value_range[2]))

# Arrange plots in a grid
do.call(grid.arrange, c(result$plots, ncol=3))

# Optionally save the plot
ggsave("topic_probabilities.pdf", marrangeGrob(grobs=result$plots, ncol=3, nrow=3),
       width=40, height=30, dpi=600)
```
```